#!/bin/env bash

ensure_directory_empty() {
  local force && force=$1 &&
    [ -n "$force" ] && return 0

  local c && c="$(find . \
    -mindepth 1 -maxdepth 1 |
    wc -c)"

  if [ "$c" -ne 0 ]; then
    echo rake new error: current directory must be empty >&2
    return 1
  fi
}

ensure_not_git_repository() {
  local force && force=$1 &&
    [ -n "$force" ] && return 0

  if git status >/dev/null 2>&1; then
    echo 'rake new error: do not rake new within an existing git repository' >&2
    return 1
  fi
}

remove_dev_files() {
  rm -rf \
    .git .gitignore .gitmodules \
    .rake/scripts/install .rake/scripts/rake \
    .rake/scripts/install .rake/scripts/rakeup \
    .rake/test &&
    find .rake/scripts/lib/funcshional \
      -maxdepth 1 -type f,d \
      -not -name src -not -name funcshional \
      -exec rm -rf {} \;
}

remove_dev_git_modules() {
  git rm .rake/test/bats .rake/test/test_helper/bats-*
}

# TODO: find out a more programmatic way
modify_makefile() {
  cat <<EOF >Makefile
# TODO: specific option settings
MAKEFLAGS += --no-print-directory

# TODO: specific rake variable settings
SHELL := /bin/bash
RAKE_ROOT_DIR := \$(dir \$(realpath \$(lastword \$(MAKEFILE_LIST))))

# TODO: specific dependency setup
FUNCSHIONAL_ROOT_DIR := \${RAKE_ROOT_DIR}.rake/scripts/lib/funcshional/

export

# simple targets
# TODO: first, present compound targets then simple targets that are more for
# internal purposes
.PHONY: help
help:
	@. \${RAKE_ROOT_DIR}.rake/scripts/help.sh

# compound targets are forwarded to a potential sub
# NOTE: This FORCE target is to correctly handle subs that are directory and as
# such, considered up to date for make
.PHONY: FORCE
FORCE:;

%: FORCE
	@. \${RAKE_ROOT_DIR}.rake/scripts/forward_to_sub.sh \$@
EOF
}

modify_help_script() {
  sed -i -E '/contribution:/,/EOF/{/EOF/!d;}' .rake/scripts/help.sh
}

init_rake_project() {
  local no_git && no_git=$1 &&
    git clone https://github.com/m374-crypt0/rake.git &&
    cd rake &&
    remove_dev_git_modules &&
    git submodule update --init &&
    cd .. &&
    mv rake/* rake/.* . &&
    rm -r rake &&
    remove_dev_files &&
    modify_makefile &&
    modify_help_script &&
    [ -z "$no_git" ] &&
    git init &&
    echo .rake/.registered_sub >.gitignore
}

print_man_page() {
  cat <<EOF
NAME
  rake - because your mono-repo deserves better

SYNOPSIS
  rake <command> [<args>]

DESCRIPTION
  Think of rake as a single make to rule them all â€“ it's the beautifully simple
  solution that lets you stop wrestling with build orchestration and get back
  to what actually matters: your code.

  At its heart, rake is just a clever Makefile that knows how to talk to other
  Makefiles. That's it. No fancy frameworks, no mysterious magic, no PhD
  required. Just good old battle-tested make, git and bash doing what they've
  done reliably for decades.

RAKE COMMANDS
  new
    This command initializes a new rake project.
    By default, you need to be in an empty directory and not within a git
    repository.
    After this command execution, your directory will contain all the necessary
    to use rake that is:
    - A .rake subdirectory containing all the necessary for rake to work
    - A Makefile able to handle compound targets.

RAKE NEW ARGS
  --force
    Normally, attemtping to create a rake project within a non-empty directory
    or within an empty directory being tracked by git is an error.
    By specifying this option, a rake project will always be created in the
    current directory

  --no-git
    Normally, creating a rake project also create a fresh git repository.
    Specifying this option tells rake not to create a new git repository to
    track this new rake project.
EOF

  return 1
}

print_generic_error_message() {
  cat <<EOF >&2
error: unrecognized command: <$1>

  type rake without argument to read the manual
EOF

  return 1
}

is_unsupported_command() {
  case "$1" in
  new)
    return 1
    ;;
  *)
    return 0
    ;;
  esac
}

parse_option() {
  local expected_option && expected_option=$1 && shift &&
    local option &&
    for option in "$@"; do
      [ "$option" = "$expected_option" ] && echo "$expected_option" && return 0
    done

  return 1
}

process_new() {
  local force &&
    force="$(parse_option --force "$@")"

  local no_git &&
    no_git="$(parse_option --no-git "$@")"

  ensure_directory_empty "$force" &&
    ensure_not_git_repository "$force" &&
    init_rake_project "$no_git"
}

process_command() {
  local command && command="$1" && shift &&
    [ "$(type -t "process_$command")" = function ] &&
    process_"$command" "$@"
}

main() {
  [ $# -eq 0 ] &&
    print_man_page ||
    local command && command="$1" &&
    is_unsupported_command "$command" &&
    print_generic_error_message "$command" &&
    return 1

  process_command "$@"
}

main "$@"
